using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.UI.Xaml.Controls;
using SteganographyInPicture.Models;
using System;
using System.Collections.Generic;

namespace SteganographyInPicture.UI.Pages.ViewModel.Implementations;

public partial class NavStudyPageViewModel : ObservableObject
{
    public NavStudyPageViewModel()
    {
        studyItems = new()
        {
            new("Стеганография",
                new()
                {
                    new("Что такое стеганография?",
                    "Стеганография — это способ спрятать информацию внутри другой информации или физического объекта так, чтобы ее нельзя было обнаружить. " +
                    "С помощью стеганографии можно спрятать практически любой цифровой контент, включая тексты, изображения, аудио- и видеофайлы. " +
                    "А когда эта спрятанная информация поступает к адресату, ее извлекают.\n\n" +
                    "Иногда контент, который нужно скрыть с помощью стеганографии, шифруют, прежде чем поместить внутрь файла другого формата. " +
                    "Даже если контент не зашифрован, он может быть каким-либо другим образом обработан, чтобы его было сложнее обнаружить.\n\n" +
                    "Стеганографию иногда сравнивают с криптографией, поскольку и то и другое – это способы секретной коммуникации. " +
                    "Однако между ними есть разница, поскольку при стеганографии данные при отправке не шифруются, а при получении не нужен ключ для расшифровки.\n\n" +
                    "Термин «стеганография» происходит от греческих слов «στεγανός» («скрытый») и «γράφω» («пишу»). " +
                    "На протяжении тысячелетий стеганографию в разных формах использовали для сохранения тайны переписки. " +
                    "Например, в древней Греции послания вырезали на деревянных дощечках, а затем скрывали под слоем воска. " +
                    "Римляне использовали разные типы невидимых чернил, которые проявлялись под воздействием тепла или света.\n\n" +
                    "Понятие «стеганография» используется и в кибербезопасности, потому что вымогатели и другие злоумышленники часто скрывают информацию при атаке на жертву. " +
                    "Например, они могут прятать данные, маскировать вредоносный код или отправлять инструкции для командных серверов, помещая все это в безобидные на первый взгляд текстовые, графические, аудио- или видеофайлы."),

                    new("Как работает стеганография",
                    "Стеганография позволяет скрывать информацию так, чтобы не вызвать подозрений. " +
                    "Одна из самых распространенных техник стеганографии — LSB (least significant bit –«наименее значащий бит»): секретные данные встраиваются в наименее значащие биты медиафайла. " +
                    "Рассмотрим это подробнее. " +
                    "Каждый пиксель в изображении состоит из трех байтов данных, соответствующих красному, зеленому и синему цветам." +
                    "Некоторые форматы изображения содержат дополнительный, четвертый байт для прозрачности, так называемый «альфа-канал».\n\n" +
                    "LSB-стеганография позволяет изменять последний бит каждого из этих байтов так, чтобы спрятать один бит информации. " +
                    "Таким образом, чтобы спрятать 1 Мб данных с помощью этой техники, понадобится графический файл объемом 8 Мбайт.\n\n" +
                    "Изменение последних битов пикселя не влияет на зрительное восприятие картинки, так что при сравнении оригинального и измененного файлов разница незаметна. \n\n" +
                    "Та же техника может применяться к другим медиафайлам, таким как звук или видео, когда информация встраивается в файл практически без изменения аудио- или видеоряда."),

                    new("Виды стеганографии",
                    "Существует пять основных видов цифровой стеганографии:" +
                    "текстовая стеганография, " +
                    "стеганография в изображениях " +
                    "стеганография в видео " +
                    "стеганография в звуке " +
                    "сетевая стеганография."),

                    new("Текстовая стеганография",
                    "Текстовая стеганография означает сокрытие данных внутри текстовых файлов. " +
                    "Это может быть форматирование текста, изменение слов внутри текста, использование контекстно-свободных грамматик для генерации читабельных текстов или генерация случайных последовательностей символов."),

                    new("Стеганография в изображениях",
                    "Это означает сокрытие данных внутри графических файлов. " +
                    "Этот вид стеганографии часто используют, чтобы скрыть информацию, поскольку цифровое изображение состоит из большого числа элементов и есть много способов спрятать данные внутри него."),

                    new("Стеганография в звуке",
                    "Секретные сообщения встраиваются в аудиосигнал, что изменяет бинарную последовательность соответствующего аудиофайла. " +
                    "Встраивание секретных сообщений в цифровой звук — это более сложный процесс по сравнению с другими."),

                    new("Стеганография в видео",
                    "Данные прячутся внутрь цифровых видеоформатов. " +
                    "Стеганография в видео позволяет скрывать большие объемы данных в движущемся потоке изображения и звука. " +
                    "Есть две разновидности стеганографии в видео: " +
                    "встраивание данных в некомпрессированное видео с последующей компрессией, встраивание данных прямо в сжатый поток видео."),

                    new("Сетевая стеганография",
                    "Сетевая, или протокольная, стеганография — это техника встраивания информации в сетевые протоколы, используемые при передаче данных, такие как TCP, UDP, ICMP и др.")
                }),


            new("Линейное распределение",
                new()
                {
                    new("Описание алгоритма", 
                    "Линейное распределение шифрованной информации происходит последовательно по массиву пикселей изображения." +
                    "Пусть массива пикселей исходного изображени назвается 'Исходные пиксели', а массива пикселей с шифрованной информацией 'Шифрованные пиксели'." +
                    "У элементов массива 'Шифрованные пиксели' заполнено столько битов каналов пикселя (R,G,B), сколько ввел пользователь. " +
                    "Т.е., например, 'глубина внедрения' равна 2 для всех каналов пикселя. " +
                    "Это значит, что в массиве 'Шифрованные пиксели', максимум может быть заполнено первые 2 бита справа (0000 0011) для каждого из каналов пикселя." +
                    "Для элементов массива 'Исходные пиксели' накладывается (логическое И) маска, которая обнуляет первые биты справа, в количестве 'глубины внедрения'. " +
                    "Например, 'глубина внедрения' равна 2, значит, маска для обнуления первых 2х битов справа - 1111 1100." +
                    "После наложения маски на элемент массива 'Исходные пиксели', накладывается (логическое ИЛИ) элемент массива 'Шифрованные пиксели'. " +
                    "В результате получается массив пикселей с зашифрованной информацией."),

                    new("Пример шифрования", 
                    "Входные параметры:\n" +
                    "1. Открытие изображения 'Исходное изображение', которое состоит из следующих пикселей: \n" +
                    "\t1.R - 101, G - 54, B - 44;\n" +
                    "\t2.R - 45, G - 64, B - 22;\n" +
                    "\t3.R - 74, G - 77, B - 34;\n" +
                    "\t4.R - 64, G - 31, B - 59;\n" +
                    "\t5.R - 24, G - 214, B - 47;\n" +
                    "\t6.R - 99, G - 145, B - 65;\n" +
                    "\t7.R - 1, G - 187, B - 99;\n" +
                    "\t8.R - 65, G - 199, B - 58;\n" +
                    "2. Ввод параметра 'Глубина внедрения' = 4. Это значит, что в каждом канале пикселя, разрешено заменить 4 младших бита.\n" +
                    "3. Указание кодировки 'Кодировка' = ASCII.\n" +
                    "4. Текст для шифрования 'Текст для шифрования' = 'Secret'\n\n" +

                    "Валидация параметров\n" +
                    "1. Необходимо убедиться в том, что тот текст, который необходимо зашифровать в изображении, не больше того количества бит, которое доступно в изображении для кодирования.\n" +
                    "Для этого нужно посчитать количество доступных бит для шифрования в изображении и количество бит, которое занимает сообщение (НЕ ЗАБЫТЬ УЧЕСТЬ 4 БАЙТА ДЛЯ УКАЗАНИЯ РАЗМЕРНОСТИ СООБЩЕНИЯ).\n" +
                    "Количество доступных бит для шифрования в изображении можно посчитать следующий образом: 'Количество пикселей в изображении' * 'Количество каналов в пикселе' * 'Глубина внедрения'.\n" +
                    "Количество бит, которое занимает сообщение, можно посчитать следующий образом: 'Текст для шифрования'(количество байт) * 8(перевод байтов в биты) + 4(Количество байт для указания размера сообщения в байтах) * 8(Перевод количество байт для указания размера сообщения в биты).\n" +
                    "Для текущего примера, 'Количество доступных бит для шифрования' = 8 * 3 * 4 = 96 бит, 'Количество бит сообщения' = 6 * 8 + 4 * 8 = 80 бит.\n" +
                    "'Количество доступных бит для шифрования' < 'Количество бит сообщения', следовательно валидация успешна.\n\n" +

                    "Шифрование текста в пиксели изображения\n" +
                    "1. Перевести 'Текст для шифрования' в битовый эквивалент.\n" +
                    "2. Добавить в начало битового элемента количества байт в тексте в виде 32 битного числа.\n " +
                    "0000 0000 0000 0000 0000 0000 0000 0110 (6) \n" +
                    "(0101 0011) (S = 83)\n" +
                    "(0110 0101) (e = 101)\n" +
                    "(0110 0011) (c = 99)\n" +
                    "(0111 0010) (r = 114)\n" +
                    "(0110 0101) (e = 101)\n" +
                    "(0111 0100) (t = 116)\n" +
                    "3. В соответствии в 'Глубиной внедрения' создать новые пиксели.\n" +
                    "\t1. R - 0, G - 0, B - 0 (в данный пиксель записаны первая тройка тетрад);\n" +
                    "\t2. R - 0, G - 0, B - 0 (в данный пиксель записаны вторая тройка тетрад);\n" +
                    "\t3. R - 0, G - 6, B - 5 (в данный пиксель записаны третья тройка тетрад);\n" +
                    "\t4. R - 3, G - 6, B - 5 (в данный пиксель записаны четвертая тройка тетрад);\n" +
                    "\t5. R - 6, G - 3, B - 7 (в данный пиксель записаны пятая тройка тетрад);\n" +
                    "\t6. R - 2, G - 6, B - 5 (в данный пиксель записаны шестая тройка тетрад);\n" +
                    "\t7. R - 7, G - 4, B - 0 (в данный пиксель записаны две последние тетрады).\n\n" +
                    
                    "Наложение 'Шифрованного текста в пикселях' на 'Исходное изображение'\n" +
                    "1. Цикл до тех пор, пока не закончатся шифрованные пиксели.\n" +
                    "2. Наложение (логическое И) на 'n-й' элемент пикселя маски для обнуления первых 'Глубина внедрения' бит.\n" +
                    "3. Наложение (логическое ИЛИ) на 'n-й' элемент пикселя 'n-го' элемента 'Шифрованного текста в пикселях'.\n\n" +
                    
                    "В итоге получается следующий результат:\n" +
                    "\t1. R - 101, G - 54, B - 44;\n" +
                    "\t2. R - 45, G - 64, B - 22;\n" +
                    "\t3. R - 74, G - 70, B - 37;\n" +
                    "\t4. R - 67 G - 22 B - 53\n" +
                    "\t5. R - 22 G - 211 B - 55\n" +
                    "\t6. R - 98 G - 182 B - 69\n" +
                    "\t7. R - 7 G - 196 B - 58;\n" +
                    "\t8. R - 65, G - 199, B - 58;"),

                    new("Пример дешифрования", 
                    "Входные данные:\n" +
                    "1. Изображение с зашифрованным текстом 'Шифрованное изображение':\n" +
                    "\t1. R - 101, G - 54, B - 44;\n" +
                    "\t2. R - 45, G - 64, B - 22;\n" +
                    "\t3. R - 74, G - 70, B - 37;\n" +
                    "\t4. R - 67 G - 22 B - 53\n" +
                    "\t5. R - 22 G - 211 B - 55\n" +
                    "\t6. R - 98 G - 182 B - 69\n" +
                    "\t7. R - 7 G - 196 B - 58;\n" +
                    "\t8.R - 65, G - 199, B - 58;\n" +
                    "2. Ввод параметра 'Глубина внедрения' = 4.\n" +
                    "3. Указание кодировки 'Кодировка' = ASCII.\n\n" +
                    
                    "Извлечение зашифрованной информации\n" +
                    "1. Цикл по всем пикселям пдодряд, покаждому каналу пикселя, пока не соберется 4 байта.\n" +
                    "2. Перевод 4 байт в Int32. Получено 'Количество зашифрованных байтов сообщения'.\n" +
                    "3. Цикл по следующим пикселям, пока не будет получено столько байт, сколько было получено в шаге 2.\n" +
                    "4. Перевод полученных байт (шаг 3) в ASCII.")
                }),


            new("Равномерное распределение",
                new()
                {
                    new("Описание алгоритма",
                    "Равномерное распределение шифрованной информации происходит равномерно по массиву пикселей изображения. " +
                    "Шаг расстановки пикселей относительно изображения, рассчитывается следующим образом: 'Количество пикселей в изображении' / 'Количество пикселей с шифрованным текстом' (См. 'Шифрование текста в пиксели изображения' из пункта 'Линейное распределение')"),
                }),

            new("Псевдослучайное распределение", 
                new()
                {
                    new("Описание алгоритма",
                    "Псевдослучайное распределение шифрованной информации происходит псевдослучайным образом по массиву пикселей изображения. " +
                    "Для определения всевдослучайного индекса пикселя, используется класс 'Random' (C#) и " +
                    "32-битный хэш код секретного элемента (строки) в виде сида для генератора случайных чисел."),
                }),
        };

        selectedItem = studyItems[0];
    }

    [ObservableProperty]
    List<StudyMenuItemModel> studyItems;

    [ObservableProperty]
    StudyMenuItemModel selectedItem;

    [RelayCommand]
    void Navigate(NavigationViewItemInvokedEventArgs args)
    {

        if (args.InvokedItemContainer != null && 
            args.InvokedItemContainer.Tag != null && 
            args.InvokedItemContainer.Tag is StudyMenuItemModel)
        {
            SelectedItem = args.InvokedItemContainer.Tag as StudyMenuItemModel ??
                throw new Exception();
            return;
        }
        SelectedItem = args.InvokedItem as StudyMenuItemModel ?? 
            throw new Exception();         
    }
}
